<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/www6vHomeHexo/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/www6vHomeHexo/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/www6vHomeHexo/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/www6vHomeHexo/images/logo.svg" color="#222">

<link rel="stylesheet" href="/www6vHomeHexo/css/main.css">


<link rel="stylesheet" href="/www6vHomeHexo/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www6v.github.io","root":"/www6vHomeHexo/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="《Streaming System》-第三章：水位">
<meta property="og:url" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/index.html">
<meta property="og:site_name" content="www6v的博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0303.png">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0307.png">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0308.png">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0309.png">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0310.png">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0312.png">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0313.png">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0314.png">
<meta property="og:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0315.png">
<meta property="article:published_time" content="2000-03-15T03:47:35.000Z">
<meta property="article:modified_time" content="2023-03-15T09:39:05.513Z">
<meta property="article:author" content="Wang Wei">
<meta property="article:tag" content="Streaming System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0303.png">

<link rel="canonical" href="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Streaming System》-第三章：水位 | www6v的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/www6vHomeHexo/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">www6v的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/www6vHomeHexo/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/www6vHomeHexo/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/www6vHomeHexo/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/www6vHomeHexo/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/www6vHomeHexo/images/avatar.gif">
      <meta itemprop="name" content="Wang Wei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="www6v的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Streaming System》-第三章：水位
        </h1>

        <div class="post-meta">





          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2000-03-15 11:47:35" itemprop="dateCreated datePublished" datetime="2000-03-15T11:47:35+08:00">2000-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-15 17:39:05" itemprop="dateModified" datetime="2023-03-15T17:39:05+08:00">2023-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/www6vHomeHexo/categories/Streaming-System/" itemprop="url" rel="index"><span itemprop="name">Streaming System</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p></p>
<span id="more"></span>

<h2><span id="目录">目录</span><a href="#目录" class="header-anchor">#</a></h2><div class="toc">

<!-- toc -->

<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E6%BA%90%E6%B0%B4%E5%8D%B0%E7%9A%84%E5%88%9B%E5%BB%BA">源水印的创建</a><ul>
<li><a href="#%E5%AE%8C%E7%BE%8E%E6%B0%B4%E5%8D%B0%E5%88%9B%E5%BB%BA">完美水印创建</a></li>
<li><a href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E6%B0%B4%E5%8D%B0%E5%88%9B%E5%BB%BA">启发式水印创建</a></li>
</ul>
</li>
<li><a href="#%E6%B0%B4%E5%8D%B0%E4%BC%A0%E6%92%AD">水印传播</a><ul>
<li><a href="#%E4%BA%86%E8%A7%A3%E6%B0%B4%E5%8D%B0%E4%BC%A0%E6%92%AD">了解水印传播</a></li>
<li><a href="#%E6%B0%B4%E5%8D%B0%E4%BC%A0%E6%92%AD%E5%92%8C%E8%BE%93%E5%87%BA%E6%97%B6%E9%97%B4%E6%88%B3">水印传播和输出时间戳</a></li>
<li><a href="#%E9%87%8D%E5%8F%A0%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A3%98%E6%89%8B%E6%83%85%E5%86%B5">重叠窗口的棘手情况</a></li>
</ul>
</li>
<li><a href="#%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0%E6%B0%B4%E5%8D%B0">百分位数水印</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E6%B0%B4%E5%8D%B0">处理时间水印</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="定义">定义</span><a href="#定义" class="header-anchor">#</a></h1><p>考虑任何连续摄取数据并输出结果的管道。我们希望解决何时可以安全地关闭事件时间窗口的一般问题，即窗口不再期望有任何数据。为了解决这个问题，我们希望相对于无限输入特征化管道正在做的进展。</p>
<p>解决事件时间窗口问题的一种天真的方法是只基于当前处理时间来设置事件时间窗口。如第一章所述，我们很快就会遇到麻烦，因为数据处理和传输不是瞬间完成的，因此处理和事件时间几乎永远不会相等。我们的管道中的任何故障或峰值可能会导致我们错误地将消息分配到窗口中。最终，这种策略失败了，因为我们没有可靠的方法来保证这样的窗口。</p>
<p>另一种直观但最终不正确的方法是考虑管道处理的消息速率。虽然这是一个有趣的指标，但速率可能会因输入变化、预期结果的变化、可用于处理的资源等因素而任意变化。更重要的是，速率无法帮助回答完整性的根本问题。具体而言，速率无法告诉我们何时看到了特定时间间隔的所有消息。在现实世界的系统中，会有消息无法通过系统进行进展的情况。这可能是暂时性错误（例如崩溃、网络故障、机器停机）的结果，也可能是需要更改应用逻辑或其他手动干预的应用级故障的结果。当然，如果发生大量故障，则处理速率指标可能是检测到这种情况的良好代理。但是，速率指标永远无法告诉我们单个消息未能通过管道进行进展。然而，即使单个这样的消息，也可能会任意影响输出结果的正确性。</p>
<p>我们需要更可靠的进展度量。为了到达那里，我们对我们的流数据做出一个基本假设：每个消息都有一个关联的逻辑事件时间戳。在不断到达的无界数据的上下文中，这种假设是合理的，因为这意味着输入数据的持续生成。在大多数情况下，我们可以将原始事件发生的时间作为其逻辑事件时间戳。由于所有输入消息都包含事件时间戳，因此我们可以检查任何管道中这些时间戳的分布。这样的管道可能被分布在许多代理上并以并行方式处理，并且没有保证单个分片之间的顺序。因此，此管道中正在进行的活动消息的事件时间戳集将形成分布，如图3-1所示。</p>
<p>消息被管道摄取、处理，最终被标记为已完成。每个消息都是“运行中”的，表示已经接收但尚未完成，还是“已完成”的，表示不需要在此消息上执行更多处理。如果我们按事件时间检查消息的分布，它将看起来像图3-1。随着时间的推移，“运行中”分布的右侧将添加更多的消息，“运行中”部分的消息将被完成并移动到“已完成”分布。</p>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"loop":"yes","screenshot":"yes","video":{"url":"/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0301.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 

<p><em>图3-1.流水线中的运行中和完成的消息事件时间分布。新消息作为输入到达并保持“运行中”，直到为它们完成处理为止。在任何给定时刻，“运行中”分布的最左侧边缘对应于最旧的未处理元素。</em></p>
<p>在此分布中有一个关键点，位于“运行中”分布的最左边缘，对应于我们管道中任何未处理消息的最旧事件时间戳。我们使用此值来定义水印：</p>
<p><strong>水印是最旧未完成的工作的单调递增时间戳。</strong></p>
<p>此定义提供了两个基本属性，使其有用：</p>
<ul>
<li><p>完整性<br>如果水印已超过某个时间戳<em>T</em>，则由其单调属性保证，不会再发生处理，因此我们可以正确地发出任何<em>T</em>时间以及<em>T</em>之前的时段的聚合结果。换句话说，水印使我们知道何时正确地关闭窗口。</p>
</li>
<li><p>可见性<br>如果消息因任何原因在管道中卡住，则水印无法前进。此外，我们将能够通过检查阻止水印前进的消息来找到问题的来源。</p>
</li>
</ul>
<h1><span id="源水印的创建">源水印的创建</span><a href="#源水印的创建" class="header-anchor">#</a></h1><p>这些水印从哪里来？为了为数据源建立水印，我们必须为从该源进入管道的每个消息分配逻辑事件时间戳。正如第2章所述，所有水印创建都属于以下两个广泛类别之一：<em>完美</em>或<em>启发式</em>。为了提醒我们完美和启发式水印之间的区别，让我们看一下第2章中的窗口求和示例的图3-2。</p>
<div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"loop":"yes","screenshot":"yes","video":{"url":"/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0302.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 
<p><em>图3-2。完美（左）和启发式（右）水印的窗口求和</em></p>
<p>请注意，区别的特点在于完美的水印确保水印考虑到<em>所有</em>数据，而启发式水印则允许一些后到数据元素。</p>
<p>水印创建为完美或启发式后，水印将在整个管道中保持不变。至于是什么使水印创建完美还是启发式，这在很大程度上取决于正在使用的源的性质。为了看到原因，让我们看一下每种类型的水印创建的一些示例。</p>
<h3><span id="完美水印创建">完美水印创建</span><a href="#完美水印创建" class="header-anchor">#</a></h3><p>完美的水印创建分配时间戳给进入的消息，以使得产生的水印是<em>严格保证</em>，即从此源再也看不到事件时间小于水印的数据了。使用完美水印创建的管道永远不必处理后到数据；也就是说，在水印超过新到达消息的事件时间之后到达的数据。然而，完美的水印创建需要对输入有完美的了解，因此对于许多真实世界的分布式输入源来说是不切实际的。以下是可以创建完美水印的用例的一些示例：</p>
<ul>
<li><p>进入时间戳</p>
<p>将进入时间分配为进入系统的数据的事件时间的源可以创建完美的水印。在这种情况下，源水印仅跟踪流水线观察到的当前处理时间。这本质上是近年来支持窗口的几乎所有流媒体系统使用的方法。</p>
<p>因为事件时间是从一个单一的、单调递增的源（实际处理时间）分配的，所以系统对于数据流中接下来的哪些时间戳将到来具有完美的了解。因此，事件时间进度和窗口语义变得容易推理。当然，缺点是水印与数据本身的事件时间没有关联；这些事件时间被有效地丢弃，水印只是跟踪数据相对于其到达系统的进度。</p>
</li>
<li><p>时间有序日志的静态集</p>
<p>时间有序日志的静态大小输入源（例如，具有静态分区集的Apache Kafka主题，其中源的每个分区包含单调递增的事件时间）将是一个相对简单的源，可以在其上创建完美的水印。为此，源将简单地跟踪未处理数据的已知和静态源分区集的最小事件时间（即，每个分区中最近读取的记录的事件时间的最小值）。</p>
<p>类似于前面提到的进入时间戳，由于静态分区集中的事件时间已知单调递增，因此系统对于接下来哪些时间戳将到来具有完美的了解。这实际上是一种有界的无序处理形式；已知分区集中的无序程度由这些分区中观察到的最小事件时间所限制。</p>
<p>通常，您只能在分区内保证单调递增的时间戳，如果在写入数据时为这些分区分配时间戳，例如通过Web前端直接记录事件到Kafka中。尽管仍然是有限的用例，但这绝对比到达数据处理系统时的进入时间戳有用得多，因为水印跟踪底层数据的有意义的事件时间。</p>
</li>
</ul>
<h3><span id="启发式水印创建">启发式水印创建</span><a href="#启发式水印创建" class="header-anchor">#</a></h3><p>另一方面，启发式水印创建创建的水印仅是估计，即事件时间小于水印的数据将不会再次出现。使用启发式水印创建的管道可能需要处理一些<em>后到数据</em>。后到数据是任何在水印超过此数据的事件时间之后到达的数据。后到数据仅在使用启发式水印创建时可能出现。如果启发式是一个合理好的启发式，那么后到数据的数量可能非常小，水印仍然有用作为完成估计。如果系统要支持需要正确性的用例（例如，像计费这样的东西），则仍然需要提供一种处理后到数据的方法。</p>
<p>对于许多真实世界的分布式输入源来说，构建完美的水印在计算或操作上是不切实际的，但是利用输入数据源的结构特征仍然可以构建高度准确的启发式水印。以下是两个示例，其中可以使用启发式水印（具有不同质量）：</p>
<ul>
<li><p>动态时间有序日志集</p>
<p>考虑一组动态结构化日志文件（每个单独的文件包含相对于同一文件中的其他记录单调递增的事件时间，但事件时间之间没有固定的关系），其中预期的完整日志文件集（即，在Kafka术语中的分区）在运行时未知。这样的输入通常在由多个独立团队构建和管理的全球规模服务中发现。在这种情况下，创建输入的完美水印是棘手的，但创建准确的启发式水印是完全可能的。</p>
<p>通过跟踪现有日志文件中未处理数据的最小事件时间、监视增长率以及利用外部信息（如网络拓扑和带宽可用性），即使缺乏有关所有输入的完美知识，也可以创建一个非常准确的水印。这种类型的输入源是在Google发现的最常见的无界数据集之一，因此我们在这些情况下有着丰富的创建和分析水印质量的经验，并看到它们在许多用例中被很好地使用。</p>
</li>
<li><p>Google Cloud Pub&#x2F;Sub</p>
<p>Cloud Pub&#x2F;Sub是一个有趣的用例。Pub&#x2F;Sub目前不保证按顺序传递；即使单个发布者按顺序发布两个消息，它们也有可能（通常很小）按顺序传递（这是由于底层架构的动态性，允许在零用户干预下扩展到非常高的吞吐量）。因此，无法保证Cloud Pub&#x2F;Sub的完美水印。然而，Cloud Dataflow团队通过利用有关Cloud Pub&#x2F;Sub中数据的可用信息构建了一个相当准确的启发式水印。本章后面将详细讨论此启发式的实现作为案例研究。</p>
</li>
</ul>
<p>考虑一个用户玩手机游戏的示例，他们的分数被发送到我们的管道进行处理：通常可以假设对于任何使用移动设备作为输入的源，提供完美的水印基本上是不可能的。由于设备长时间离线的问题，没有办法为这种数据源提供任何合理的完整性估计。但是，您可以想象构建一个准确地跟踪当前在线设备的输入完整性的水印，类似于上面描述的Google Pub&#x2F;Sub水印。从提供低延迟结果的角度来看，处于活动状态的用户可能是最相关的用户子集，因此这通常不是您最初想到的缺点。</p>
<p>总的来说，启发式水印的创建越了解源，启发式就越好，就越少见到后到数据项。鉴于源类型、事件分布和使用模式会有很大的变化，因此没有一种万能的解决方案。但是无论哪种情况（完美还是启发式），在输入源处创建水印后，系统可以完美地传播水印。这意味着完美水印将在下游保持完美，启发式水印将严格保持与创建时一样的启发式。这是水印方法的好处：您可以将管道中的完整性跟踪复杂性完全减少到在源处创建水印的问题上。</p>
<h1><span id="水印传播">水印传播</span><a href="#水印传播" class="header-anchor">#</a></h1><p>到目前为止，我们仅考虑了单个操作或阶段内输入数据的水印。然而，大多数实际的流水线都由多个阶段组成。了解水印在独立阶段之间如何传播对于理解它们如何影响整个流水线以及其结果的观察延迟非常重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**流水线阶段**</span><br><span class="line"></span><br><span class="line">每次通过某个新的维度将数据分组到流水线中时，通常需要不同的阶段。例如，如果您有一个流水线，它消耗原始数据，计算一些按用户统计的数据，然后使用这些按用户统计的数据计算一些按团队统计的数据，那么您很可能会得到一个三阶段的流水线：</span><br><span class="line"></span><br><span class="line">- 消耗原始数据的阶段</span><br><span class="line">- 将数据按用户分组并计算每个用户的统计数据的阶段</span><br><span class="line">- 将数据按团队分组并计算每个团队的统计数据的阶段</span><br><span class="line"></span><br><span class="line">我们将在第6章中更多地了解有关数据分组对流水线形状的影响。</span><br></pre></td></tr></table></figure>



<p>水印是在输入源处创建的，就像前面讨论的那样。然后在数据通过系统时，它们在概念上通过系统流动。您可以在不同粒度级别上跟踪水印。对于由多个独立阶段组成的流水线，每个阶段可能都跟踪其自己的水印，其值是其前面的所有输入和阶段的函数。因此，流水线后面的阶段将具有更过去的水印（因为它们看到的整体输入要少）。</p>
<p>我们可以在流水线中任何单个操作或阶段的边界上定义水印。这不仅有助于了解流水线中每个阶段的相对进度，而且对于独立地且尽快为每个单独的阶段分派及时结果非常有用。我们为阶段边界处的水印给出以下定义：</p>
<ul>
<li>输入水印（input watermark）：捕获该阶段上游的所有进度（即该阶段的输入数据完整程度）。对于源，输入水印是创建输入数据水印的源特定函数。对于非源阶段，输入水印定义为所有上游源和阶段的所有分片&#x2F;分区&#x2F;实例的输出水印的最小值。</li>
<li>输出水印（output watermark）：捕获阶段本身的进度，本质上定义为阶段的输入水印和所有非延迟数据激活消息的事件时间的最小值。 “活动”确切包含的内容在很大程度上取决于给定阶段实际执行的操作以及流处理系统的实现。它通常包括缓冲以进行聚合但尚未向下游实现的数据，正在等待输出数据传输到下游阶段等。</li>
</ul>
<p>定义特定阶段的输入和输出水印的一个好处是我们可以使用它们计算阶段引入的事件时间延迟量。将阶段的输出水印值减去其输入水印值可得出阶段引入的事件时间延迟或滞后。此滞后是每个阶段输出相对于实际时间的延迟程度的概念。例如，执行10秒窗口聚合的阶段将具有10秒或更多的滞后，这意味着阶段的输出至少要比输入和实际时间延迟那么多。输入和输出水印的定义提供了整个流水线中水印的递归关系。流水线中的每个后续阶段都会根据阶段的事件时间滞后必要地延迟水印。</p>
<p>每个阶段内的处理也不是单一的。我们可以将一个阶段内的处理划分为具有多个概念组件的流，每个组件都有助于生成输出水印。如前所述，这些组件的确切性质取决于阶段执行的操作和系统的实现。从概念上讲，每个这样的组件都充当缓冲区，其中活动消息可以驻留，直到某个操作完成。例如，数据到达时，它会被缓冲以进行处理。然后，处理可能会将数据写入状态以进行延迟聚合。当触发延迟聚合时，它可能会将结果写入等待下游阶段消耗的输出缓冲区，如图3-3所示。</p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0303.png" class>

<p><em>图3-3。流系统阶段的示例系统组件，包含正在进行的数据的缓冲区。每个都将有关联的水印跟踪，阶段的整体输出水印将是所有此类缓冲区的水印的最小值。</em></p>
<p>我们可以使用自己的水印跟踪每个这样的缓冲区。每个阶段缓冲区中的水印的最小值形成该阶段的输出水印。因此，输出水印可以是以下内容的最小值：</p>
<ul>
<li>每个发送阶段的<em>每个源</em>水印。</li>
<li><em>每个外部输入</em>水印——用于流水线外部的源</li>
<li><em>每种类型的状态</em>组件水印——可以写入每种状态</li>
<li><em>每个接收阶段</em>的水印</li>
</ul>
<p>在这个粒度级别上提供水印也可以更好地了解系统的行为。水印跟踪系统中各个缓冲区中的消息位置，从而更容易诊断卡住的问题。</p>
<h3><span id="了解水印传播">了解水印传播</span><a href="#了解水印传播" class="header-anchor">#</a></h3><p>为了更好地了解输入和输出水印之间的关系以及它们如何影响水印传播，让我们看一个例子。我们考虑游戏得分，但不是计算团队得分的总和，而是试图衡量用户参与水平。我们将首先通过计算每个用户会话的长度来实现这一点，假设用户参与游戏的时间是他们享受游戏程度的合理代理。在回答我们的四个问题以计算会话长度一次后，我们将再次回答这些问题，以在固定时间段内计算平均会话长度。</p>
<p>为了使我们的示例更加有趣，假设我们正在使用两个数据集，一个用于移动得分，另一个用于控制台得分。我们希望通过整数求和在这两个独立数据集上并行执行相同的得分计算。一个管道正在计算在移动设备上玩游戏的用户的得分，而另一个管道则是针对在家庭游戏机上玩游戏的用户，可能是由于针对不同平台采用了不同的数据收集策略。重要的是，这两个阶段执行相同的操作，但是在不同的数据上执行，因此输出的水印非常不同。</p>
<p>首先，让我们看一下示例3-1，以了解该管道的第一部分的缩写代码是什么样子的。</p>
<p><em>示例3-1。计算会话长度</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PCollection&lt;Double&gt; mobileSessions = IO.read(<span class="keyword">new</span> <span class="title class_">MobileInputSource</span>())</span><br><span class="line">.apply(Window.into(Sessions.withGapDuration(Duration.standardMinutes(<span class="number">1</span>)))            .triggering(AtWatermark())</span><br><span class="line">             .discardingFiredPanes())</span><br><span class="line">.apply(CalculateWindowLength());</span><br><span class="line"></span><br><span class="line">PCollection&lt;Double&gt; consoleSessions = IO.read(<span class="keyword">new</span> <span class="title class_">ConsoleInputSource</span>())</span><br><span class="line">.apply(Window.into(Sessions.withGapDuration(Duration.standardMinutes(<span class="number">1</span>)))            .triggering(AtWatermark())</span><br><span class="line">             .discardingFiredPanes())</span><br><span class="line">.apply(CalculateWindowLength());</span><br></pre></td></tr></table></figure>

<p>在这里，我们独立读取每个输入，而不是之前按团队键入我们的集合，在这个示例中，我们按用户键入。之后，对于每个管道的第一阶段，我们窗口进入会话，然后调用名为CalculateWindowLength的自定义PTransform。这个PTransform仅通过键（即用户）进行分组，然后通过将当前窗口的大小视为该窗口的值来计算每个用户会话长度。在这种情况下，我们对默认触发器（AtWatermark）和累积模式（discardingFiredPanes）设置感到满意，但是为了完整起见，我已经列出了它们。两个特定用户的每个管道的输出可能看起来像图3-4。</p>
<div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"loop":"yes","screenshot":"yes","video":{"url":"/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0304.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
<p><em>图3-4。两个不同输入管道中的每个用户会话长度</em></p>
<p>因为我们需要跨多个阶段跟踪数据，所以我们将与Mobile Scores相关的一切都记录为红色，与Console Scores相关的一切都记录为蓝色，而Figure 3-5中的平均会话长度的水印和输出为黄色。</p>
<p>我们已经回答了计算单个会话长度的“什么”，“何地”，“何时”和“如何”这四个问题。接下来，我们将再次回答这些问题，将这些会话长度转换为固定时间窗口内的全局会话长度平均值。这需要我们首先将两个数据源展平为一个，然后重新窗口进入固定窗口；我们已经捕捉到会话中重要的本质，在我们计算的会话长度值中，我们现在想在一天中的一致时间窗口内计算这些会话的全局平均值。示例3-2显示了此代码。</p>
<p><em>示例3-2。计算会话长度</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PCollection&lt;Double&gt; mobileSessions = IO.read(new MobileInputSource())</span><br><span class="line">.apply(Window.into(Sessions.withGapDuration(Duration.standardMinutes(1)))            .triggering(AtWatermark())</span><br><span class="line">             .discardingFiredPanes())</span><br><span class="line">.apply(CalculateWindowLength());</span><br><span class="line"></span><br><span class="line">PCollection&lt;Double&gt; consoleSessions = IO.read(new ConsoleInputSource())</span><br><span class="line">.apply(Window.into(Sessions.withGapDuration(Duration.standardMinutes(1)))            .triggering(AtWatermark())</span><br><span class="line">             .discardingFiredPanes())</span><br><span class="line">.apply(CalculateWindowLength());</span><br><span class="line"></span><br><span class="line">PCollection&lt;Float&gt; averageSessionLengths = PCollectionList</span><br><span class="line">  .of(mobileSessions).and(consoleSessions)</span><br><span class="line">  .apply(Flatten.pCollections())</span><br><span class="line">  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2)))</span><br><span class="line">               .triggering(AtWatermark())</span><br><span class="line">  .apply(Mean.globally());</span><br></pre></td></tr></table></figure>

<p>如果我们看到这个管道在运行，它看起来会像图3-5。与以前一样，两个输入管道正在计算移动和控制台玩家的单个会话长度。然后，这些会话长度进入管道的第二个阶段，在其中计算了固定窗口内的全局会话长度平均值。</p>
<div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"loop":"yes","screenshot":"yes","video":{"url":"/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0305.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 
<p><em>图3-5。移动和控制台游戏会话的平均会话长度</em></p>
<p>鉴于这里发生了很多事情，让我们走一遍这个例子。这里的两个重要点是：</p>
<ul>
<li>每个Mobile Sessions和Console Sessions阶段的<em>输出水印</em>至少与每个对应的输入水印一样旧，并且实际上要旧一些。这是因为在真实系统中，计算答案需要时间，我们不允许输出水印在给定输入的处理完成之前向前推进。</li>
<li>平均会话长度阶段的<em>输入水印</em>是两个直接上游阶段的输出水印的最小值。</li>
</ul>
<p>结果是下游输入水印是上游输出水印的最小组合的别名。请注意，这与本章前面对这两种类型的水印的定义相匹配。还要注意，下游的水印进一步落后，捕捉到上游阶段将比后续阶段超前一些时间的直观概念。</p>
<p>这里值得注意的一个观察是，我们能够在示例3-1中再次询问这些问题，以从根本上改变管道的结果。以前，我们只是计算单个用户会话长度，现在我们计算了两分钟的全局会话长度平均值。这提供了对我们的游戏玩家的整体行为更深入的了解，让您微小地了解了简单数据转换和真正的数据科学之间的差异。</p>
<p>更好的是，既然我们了解了这个管道运作的基础知识，我们现在可以更仔细地查看与再次询问这四个问题相关的更微妙的问题：<em>输出时间戳</em>。</p>
<h3><span id="水印传播和输出时间戳">水印传播和输出时间戳</span><a href="#水印传播和输出时间戳" class="header-anchor">#</a></h3><p>在图3-5中，我忽略了一些输出时间戳的细节。但是，如果您仔细观察图中的第二个阶段，您会发现从第一个阶段输出的每个数据都被赋予了一个时间戳，该时间戳与其窗口的结束时间相匹配。虽然这是一个相当自然的输出时间戳选择，但它并不是唯一有效的选择。正如您在本章早期所知道的，水印永远不允许后移。在这种限制下，您可以推断出对于给定窗口的有效时间戳范围始于窗口中最早的非延迟记录的时间戳（因为只有非延迟记录保证保持水印），并延伸到正无穷。这是相当多的选择。然而，在实践中，通常只有几个选择在大多数情况下是有意义的：</p>
<ul>
<li><p>窗口结束时间</p>
<p>如果您希望输出时间戳代表窗口边界，则使用窗口结束时间是唯一安全的选择。正如我们很快就会看到的那样，这也允许水印的平稳进展，比其他选项更加平稳。</p>
</li>
<li><p>第一个非延迟元素的时间戳</p>
<p>在您希望尽可能保守地保持水印时，使用第一个非延迟元素的时间戳是一个不错的选择。然而，这种权衡的代价是水印的进展可能会更加受到阻碍，我们很快也会看到。</p>
</li>
<li><p>特定元素的时间戳</p>
<p>对于某些用例，某些其他任意时间戳（从系统的角度来看）的时间戳是正确的选择。想象一下这样一个用例，您正在将查询流连接到该查询的结果流的点击流上。在执行连接之后，一些系统会发现查询的时间戳更有用；其他人则更喜欢单击的时间戳。只要它对应于没有延迟到达的元素，任何这样的时间戳都是从水印正确性的角度来看是有效的。</p>
</li>
</ul>
<p>考虑了一些备选项之后，让我们看看输出时间戳选择对整个管道的影响。为了使变化尽可能显著，在示例3-3和图3-6中，我们将使用最早的时间戳作为窗口的时间戳：第一个非延迟元素的时间戳。</p>
<p><em>示例3-3。平均会话长度管道，设置为最早元素的会话窗口输出时间戳</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PCollection&lt;Double&gt; mobileSessions = IO.read(new MobileInputSource())`</span><br><span class="line">.apply(Window.into(Sessions.withGapDuration(Duration.standardMinutes(1)))             .triggering(AtWatermark())</span><br><span class="line">              .withTimestampCombiner(EARLIEST)</span><br><span class="line">              .discardingFiredPanes())</span><br><span class="line">.apply(CalculateWindowLength());</span><br><span class="line"></span><br><span class="line">PCollection&lt;Double&gt; consoleSessions = IO.read(new ConsoleInputSource())</span><br><span class="line">.apply(Window.into(Sessions.withGapDuration(Duration.standardMinutes(1)))            .triggering(AtWatermark())</span><br><span class="line">             .withTimestampCombiner(EARLIEST)</span><br><span class="line">             .discardingFiredPanes())</span><br><span class="line">.apply(CalculateWindowLength());</span><br><span class="line"></span><br><span class="line">PCollection&lt;Float&gt; averageSessionLengths = PCollectionList</span><br><span class="line">  .of(mobileSessions).and(consoleSessions)</span><br><span class="line">  .apply(Flatten.pCollections())</span><br><span class="line">  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2)))</span><br><span class="line">               .triggering(AtWatermark())</span><br><span class="line">  .apply(Mean.globally());</span><br></pre></td></tr></table></figure>

<div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"loop":"yes","screenshot":"yes","video":{"url":"/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0306.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 
<p><em>图3-6。以最早元素的时间戳为输出时间戳的会话平均长度</em></p>
<p>为了突出输出时间戳选择的影响，请查看第一阶段中的虚线，显示每个阶段的输出水印被保持的时间。由于我们选择了时间戳，输出水印后移，与图3-7和3-8相比，在这些示例中，输出时间戳被选择为窗口结束时间。从这个图表中，您可以看出第二个阶段的输入水印因此也被推迟了。</p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0307.png" class>
<p><em>图3-7。具有不同窗口输出时间戳的水印和结果的比较。</em><br><em>本图中的水印对应于会话窗口的结束时间戳（即图3-5）。</em></p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0308.png" class>
<p><em>图3-8。在这个图中，水印位于会话窗口的开始处（即图3-6）。</em><br><em>我们可以看到，这个图中的水印线被推迟了，导致平均会话长度不同。</em></p>
<p>就与图3-7相比这个版本的区别，值得注意的有两点：</p>
<ul>
<li><p>水印延迟</p>
<p>与图3-5相比，图3-6中的水印进展要慢得多。这是因为第一个阶段的输出水印被保留到每个窗口中的第一个元素的时间戳，直到该窗口的输入变得完整。只有在给定的窗口已经成为物化后，输出水印（以及下游输入水印）才被允许向前推进。</p>
</li>
<li><p>语义差异</p>
<p>因为现在会话时间戳被分配为与会话中最早的非延迟元素相匹配，所以当我们在下一个阶段计算会话长度平均值时，单个会话经常会落入不同的固定窗口桶中。两种选择都没有本质上的对错；它们只是不同的。但是，重要的是要理解它们将是不同的，并且具有它们将不同的直觉，以便在需要时为您特定的用例做出正确的选择。</p>
</li>
</ul>
<h3><span id="重叠窗口的棘手情况">重叠窗口的棘手情况</span><a href="#重叠窗口的棘手情况" class="header-anchor">#</a></h3><p>关于输出时间戳的另一个微妙但重要的问题是如何处理滑动窗口。将输出时间戳设置为最早元素的幼稚方法很容易导致下游的延迟，因为水印被（正确地）阻止。要了解原因，请考虑具有两个阶段的示例管道，每个阶段都使用相同类型的滑动窗口。假设每个元素都在三个连续的窗口中结束。随着输入水印的推进，滑动窗口的期望语义如下：</p>
<ul>
<li>第一个窗口在第一阶段完成并向下游发出。</li>
<li>然后在第二阶段中，第一个窗口完成并也可以向下游发出。</li>
<li>一段时间后，第二个窗口在第一阶段完成…等等。</li>
</ul>
<p>然而，如果将输出时间戳选择为面板中第一个非延迟元素的时间戳，实际发生的是以下情况：</p>
<ul>
<li>第一个窗口在第一阶段完成并向下游发出。</li>
<li>第二阶段的第一个窗口仍无法完成，因为其输入水印被上游第二个和第三个窗口的输出水印所阻止。这些水印被正确地阻止，因为这些窗口的输出时间戳使用最早元素的时间戳。</li>
<li>第二个窗口在第一阶段完成并向下游发出。</li>
<li>在上游第三个窗口的带领下，第二阶段的第一个和第二个窗口仍无法完成。</li>
<li>第三个窗口在第一阶段完成并向下游发出。</li>
<li>第二阶段的第一个，第二个和第三个窗口现在都能够完成，最终一次性发出所有三个窗口。</li>
</ul>
<p>尽管这种窗口处理的结果是正确的，但这导致了结果以不必要的延迟方式被实现。因此，Beam对于重叠窗口具有特殊逻辑，以确保窗口N+1的输出时间戳始终大于窗口N的结束时间戳。</p>
<h1><span id="百分位数水印">百分位数水印</span><a href="#百分位数水印" class="header-anchor">#</a></h1><p>到目前为止，我们一直关注以活动信息在阶段中的最小事件时间为度量的水印。跟踪最小值允许系统知道所有先前时间戳都已经被考虑。另一方面，我们可以考虑活动消息的事件时间分布，并利用它来创建更细粒度的触发条件。</p>
<p>我们可以选择考虑分布的任何百分位数，并且说我们保证处理了这个百分比的所有具有较早时间戳的事件。</p>
<p>这个方案的优点是什么？如果对于业务逻辑来说，“主要正确”已经足够，那么百分位数水印提供了一种机制，可以使水印比通过从水印中剔除长尾的异常数据来跟踪最小事件时间更快、更平稳。图3-9展示了一个紧凑的事件时间分布，其中90百分位数水印接近100百分位数。图3-10展示了一个离群点更远的情况，因此90百分位数水印显着领先于100百分位数水印。通过从水印中剔除异常数据，百分位数水印仍然可以跟踪分布的大部分，而不会被异常数据拖延。</p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0309.png" class>
<p><em>图3-9. 看起来正常的水印直方图</em></p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0310.png" class>
<p><em>图3-10. 含有异常值的水印直方图</em></p>
<p>图3-11展示了使用分位数水印绘制两分钟固定窗口边界的示例。我们可以基于到达数据的时间戳的分位数，通过百分位数水印绘制早期边界。</p>
<div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"loop":"yes","screenshot":"yes","video":{"url":"/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0311.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 
<p><em>图3-11. 百分位数水印变化的影响。随着百分位数的增加，窗口中包含更多的事件：但是，材料化窗口的处理时间延迟也会增加。</em></p>
<p>图3-11展示了33百分位数、66百分位数和100百分位数（全）水印，跟踪数据分布中的相应时间戳百分位数。如预期的那样，这些允许绘制较早的边界，而不是跟踪完整的100百分位数水印。请注意，33百分位数和66百分位数水印都允许较早的窗口触发，但以更多的数据被标记为延迟为代价。例如，对于第一个窗口[12:00，12:02)，基于33百分位数水印关闭的窗口只包括四个事件，并在12:06的处理时间材料化结果。如果我们使用66百分位数水印，则相同的事件时间窗口将包括七个事件，并在12:07的处理时间材料化。使用100百分位数水印包括所有十个事件，并推迟材料化结果，直到12:08的处理时间。因此，百分位数水印提供了一种调整材料化结果的延迟和精度之间权衡的方法。</p>
<h1><span id="处理时间水印">处理时间水印</span><a href="#处理时间水印" class="header-anchor">#</a></h1><p>到目前为止，我们一直在看水印与流经我们系统的数据有关的情况。我们已经看到了查看水印如何帮助我们识别最旧数据和实时数据之间的总延迟。然而，这还不足以区分旧数据和延迟的系统。换句话说，仅仅通过我们迄今为止定义的事件时间水印来检查，我们无法区分正在快速处理一小时前的数据和被延迟一个小时的实时数据的系统。</p>
<p>为了区分这一点，我们需要更多的东西：处理时间水印。我们已经看到，在流处理系统中有两个时间域：处理时间和事件时间。到目前为止，我们完全在事件时间域中定义了水印，作为流经系统的数据时间戳的函数。这是一个事件时间水印。我们现在将同样的模型应用于处理时间域，定义一个处理时间水印。</p>
<p>我们的流处理系统不断执行操作，例如在管道的当前或上游阶段之前执行的操作之间移动消息、读取或写入消息到持久状态或触发基于水印进度的延迟聚合。因此，正如数据元素“流”通过系统一样，处理这些元素涉及的操作的级联也“流”通过系统。</p>
<p>我们以完全相同的方式定义处理时间水印，就像我们迄今为止定义的事件时间水印一样，只不过我们使用最旧尚未完成的操作的处理时间戳，而不是使用最旧尚未完成的工作的事件时间戳。延迟处理时间水印的例子可能是从一个阶段到另一个阶段的消息传递被阻塞、读取状态或外部数据的I&#x2F;O调用被阻塞，或者在处理过程中发生的阻止处理完成的异常。</p>
<p>因此，处理时间水印提供了一个单独于数据延迟的处理延迟概念。为了理解这个区别的价值，考虑图3-12中查看事件时间水印延迟的情况。</p>
<p>我们看到数据延迟单调递增，但是没有足够的信息来区分系统卡住和数据卡住的情况。只有查看处理时间水印，如图3-13所示，我们才能区分这些情况。</p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0312.png" class> 
<p><em>图3-12. 事件时间水印增加。从这些信息中无法知道这是由于数据缓冲还是系统处理延迟引起的。</em></p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0313.png" class> 
<p><em>图3-13. 处理时间水印也在增加。这表明系统处理被延迟了。</em></p>
<p>在第一种情况（图3-12）中，当我们检查处理时间水印延迟时，我们发现它也在增加。这告诉我们，系统中的一个操作被卡住了，卡住也导致数据延迟落后。这可能发生在网络问题阻止管道阶段之间的消息传递或发生故障并正在进行重试的情况下。一般来说，增长的处理时间水印表示一个问题，阻止了必要于系统功能的操作完成，通常需要用户或管理员干预来解决。</p>
<p>在第二种情况下，如图3-14所示，处理时间水印延迟很小。这告诉我们，没有卡住的操作。事件时间水印延迟仍在增加，这表明我们有一些缓冲状态正在等待排空。例如，如果我们正在等待窗口边界来通过及时触发器发出聚合，那么我们可能会缓冲一些状态，这对应于管道的正常操作，如图3-15所示。</p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0314.png" class> 
<p><em>图3-14. 事件时间水印延迟增加，处理时间水印稳定。这表明数据在系统中被缓冲并等待处理，而不是系统操作阻止了数据处理的迹象。</em></p>
<img src="/www6vHomeHexo/2000/03/15/streamingSystemChapter3/stsy_0315.png" class> 
<p><em>图3-15. 固定窗口的水印延迟。随着元素为每个窗口缓冲，事件时间水印延迟增加，随着每个窗口的聚合通过及时触发器发出，事件时间水印延迟减少，而处理时间水印仅跟踪系统级延迟（在健康的管道中仍保持相对稳定）。</em></p>
<p>因此，处理时间水印是区分系统延迟和数据延迟的有用工具。除了可见性外，我们可以在系统实现级别使用处理时间水印来执行任务，例如临时状态的垃圾回收（Reuven在第5章中对一个示例进行了更多的讨论）。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Wang Wei
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/" title="《Streaming System》-第三章：水位">https://www6v.github.io/www6vHomeHexo/2000/03/15/streamingSystemChapter3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/www6vHomeHexo/tags/Streaming-System/" rel="tag"># Streaming System</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/www6vHomeHexo/2000/03/14/streamingSystemChapter4Original/" rel="prev" title="《Streaming System》-Chapter4. Advanced Windowing">
      <i class="fa fa-chevron-left"></i> 《Streaming System》-Chapter4. Advanced Windowing
    </a></div>
      <div class="post-nav-item">
    <a href="/www6vHomeHexo/2000/03/15/streamingSystemChapter3Original/" rel="next" title="《Streaming System》-Chapter 3. Watermarks">
      《Streaming System》-Chapter 3. Watermarks <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Wei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/www6vHomeHexo/archives/">
        
          <span class="site-state-item-count">394</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/www6vHomeHexo/categories/">
          
        <span class="site-state-item-count">240</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/www6vHomeHexo/tags/">
          
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/www6v" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;www6v" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:www6v@126.com" title="E-Mail → mailto:www6v@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Wei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/www6vHomeHexo/lib/anime.min.js"></script>
  <script src="/www6vHomeHexo/lib/velocity/velocity.min.js"></script>
  <script src="/www6vHomeHexo/lib/velocity/velocity.ui.min.js"></script>

<script src="/www6vHomeHexo/js/utils.js"></script>

<script src="/www6vHomeHexo/js/motion.js"></script>


<script src="/www6vHomeHexo/js/schemes/muse.js"></script>


<script src="/www6vHomeHexo/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/www6vHomeHexo/js/local-search.js"></script>













  

  

</body>
</html>
